<!doctype html>
<head>
<meta charset="utf-8" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=59181255"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '59181255');
</script>

<link href="https://fonts.googleapis.com/css?family=Itim|Roboto+Mono:300,400,500,700&display=swap" rel="stylesheet">

<script src="js/lodash.min.js"></script>
<script src="js/d3.v5.min.js"></script>
<script src="js/vue.min.js"></script>
<script src="js/jstat-mybuild.js"></script>

<style>

html, body, #app{
  height: 100%;
}

*{
  font-family: 'Roboto Mono', monospace;
  font-size: 16px;
  font-weight: 400;
}

.handwriting, .handwriting *{
  font-family: 'Itim';
}

.pset  img{
  display: block;
}

.samples-chart{
  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}

.bayes-comp{
  display: inline-block;
  position:relative;
  width: 150px;
  height: 270px;
  vertical-align: top;
  text-align: center;

  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}
.bayes-comp .label *{
  font-size: 14px;
  text-align: center;
}
.bayes-comp .rainbow{
  position:absolute; 
  left: 8px;
  width:90%; 
  opacity:0.5
}

.dot{
  border-radius: 50%;
  width: 12px;
  height: 12px;
  background-color: #2F77A1;
  cursor: ns-resize;
}

.dot:hover{
  border: 1px solid white;
}

text{
  font-size: 13px;
}

div{
  margin-bottom: 16px;
}

.normal-div, .normal-div div{
  margin-bottom: 0px;
}

h4{
  font-size: 18px;
  font-weight: 500;
}

a{
  color: #337ab7; /* bootstrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}


.small-text, .small-text *{
  font-size: 16px;
}
.smaller-children, .smaller-children *{
  font-size: 13px;
}

button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px; 
  padding: 8px 16px;
  margin: 8px;
}
.buton:hover,.clicked-button{
  color: white;
  background-color: #555;
}
.bold{
  font-weight: 700;
}

/* https://w3bits.com/rainbow-text/ 
.rainbow-text {
  background-image: repeating-linear-gradient(45deg, violet, indigo, blue, green, orange, red, violet);
  text-align: center;
  background-size: 800% 800%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow 4s ease infinite;
}

@keyframes rainbow { 
    0%{background-position:0% 50%}
    50%{background-position:100% 25%}
    100%{background-position:0% 50%}
}*/

.rainbow-text{
  font-size: 16px;
  margin: 8px;
  font-weight: 700;
  background: linear-gradient(to right, orange, yellow, cyan, violet);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.toc-chapter{
  display: grid;
  grid-template-columns: 50px auto;
}

.toc-chapter:hover{
  background-color: #ddd;
}

.toc-chapter:hover img{
    -webkit-filter: none;
  filter: none;
}

.toc-closed:hover{
  background-color: #eee;
}

.bayes-toggle{
  width: 0px; /* needed so toggle doesn't capture horizontal click space */
  color: #999;
}

.bayes-toggle:hover{
  color: #000;
}

.thanks, .thanks * {
  font-size: 14px;
}

.disabled, .disabled * { 
  pointer-events: none;
  user-select: none; 
}

.story-point-silhouette{
  -webkit-filter: contrast(0%) brightness(90%);
  filter: contrast(0%) brightness(90%);
  cursor: pointer;
}
.story-point-silhouette:hover{
  -webkit-filter: none;
  filter: none;
}

.fair-bet *{
  font-size: 12px;
}
</style>

</head>

<body>


<div id="app" @click="mainClick($event)">
<div style="position:relative; padding: 16px; width: 500px;" :style="appStyle">

  <h1 class="handwriting" style="font-size:48px">Adventures in Cognitive Biases</h1>

  <div ref="toc" class="normal-div" style="position: relative; z-index:1; width:240px;">

    <div :style="{opacity: showTOC ? 0 : 1}" 
         @click="showTOC = true" class="toc-closed"
         style="padding: 4px">
      <img :src="'images/' + currentChapter.image" 
           style="max-width:50px; max-height:100px">

      <span style="top:60px; font-size:12px; display: inline-block; margin:8px; vertical-align: top">
        <bold style="font-size:12px">{{ chapterInd < chapters.length-1 ? 'Chapter ' + chapterInd : 'Thanks' }}</bold>
        <br> 
        {{currentChapter.description}}
      </span>
    
      <span style="position:absolute; right:16px; top:16px">â–¼</span>
    </div>

    <div style="position:absolute; top: 0px; left:0px; width:100%">
      <div v-if="showTOC"
           v-for="(chapter, ind) in chapters"
           @click="showTOC = false; chapterInd = ind"
           class="toc-chapter"
           style="padding:4px; border:1px solid #eee"
           :style="{'background-color': currentChapter == chapter ? '#eee': 'rgb(250,250,250)'}">
        <img :class="{'story-point-silhouette': currentChapter !== chapter}"
            :src="'images/' + chapter.image" 
            style="max-width:50px; max-height:100px">
        <span style="top:60px; font-size:12px; display: inline-block; margin:8px;">
          <bold style="font-size:12px">{{ ind < chapters.length-1 ? 'Chapter ' + ind : '???' }}</bold>
          <br> 
          {{chapter.description}}
        </span>
      </div>
    </div>
  </div>


<keep-alive>
  <component v-bind:is="visibleScreen" style="position:relative; margin-top: 16px" :root-mouse-event="mouseEvent"></component>
</keep-alive>


</div> <!-- end center div -->
</div> <!-- end #app -->



<script type="text/x-template" id="buton-group-template">
<div>
  <slot></slot>
  <div v-if="showHint" class="hint"><slot name="hint"></slot></div>
</div>
</script>


<script type="text/x-template" id="bold-template">
<span class="bold"><slot></slot></span> 
</script>

<script type="text/x-template" id="pset-template">
  <div class="pset">
    <slot></slot>
  </div>
</script>


<script type="text/x-template" id="distribution-template">
<div class="distribution" style="display:inline-block; text-align:center">
<div v-if="title" style="text-align: center; font-size: 16px; text-transform:capitalize" :style="titleStyle">{{title}}</div>

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
      <rect v-for="outcome in outcomes"
          :x="xScale(outcome.x)"
          :y="yScale(outcome.y)"
          :width="xScale.bandwidth()"
          :height="chartHeight - yScale(outcome.y)"
          :key="outcome.x"
          :fill="barColor"/>

      <!-- top of bar 
      <text v-for="outcome in outcomes" 
        :x="xScale(outcome.x) + xScale.bandwidth()/2 - 8"
        :y="yScale(outcome.y) - 2">
        {{ outcome.y }}
      </text>-->
    </g>
</svg>
</div>
</script>

<!-- <triple-bayes 
  :hypotheses="['Nice', 'Evil']" 
  :config="{prior: {dist: [1, 1], correct: [1, 2], isActive: true, isDraggable:true}, likelihood: {dist: [10, 1], isActive: true, isDraggable: true}, posterior: {}}"></triple-bayes> -->
<script type="text/x-template" id="triple-bayes-template">
<div style="display:inline-block">

<div v-if="hasKey('prior')" class="bayes-comp" :style="compStyle('prior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('prior')}}</div>
    <div>{{subtitle('prior')}}</div>
  </div>

  <samples-chart 
  :xdomain="hypotheses"
  :dist="arrToDist(priorArr)"
  :isDraggable="isDraggable('prior')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :showRatio="true"
  :colors="colors"
  @dist-changed="priorChanged" /> 
</div>


<div v-if="hasKey('likelihood')" class="bayes-comp" :style="compStyle('likelihood')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('likelihood')}}</div>
    <div>{{subtitle('likelihood')}}</div>
  </div>
  <samples-chart
  :xdomain="hypotheses"
  :dist="arrToDist(likelihoodArr)"
  :isDraggable="isDraggable('likelihood')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  @dist-changed="likelihoodChanged" /> 
</div>

<div v-if="hasKey('posterior')" class="bayes-comp" :style="compStyle('posterior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('posterior')}}</div>
    <div>{{subtitle('posterior')}}</div>
  </div>
  <samples-chart 
  :xdomain="hypotheses"
  :dist="posteriorDist"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :showRatio="true"
  :colors="colors"
  ref="posterior-samples-chart" /> 
</div>

<div v-if="showFeedback && !allCorrect" class="handwriting normal-div">
  <div>Not quite. Try again!</div>
  <slot name="hint"></slot>
</div>


<div v-if="showFeedback && allCorrect" class="handwriting normal-div">
  <div>Correct!</div>
  <slot name="yay"></slot>
</div>

<div v-if="(isDraggable('prior') || isDraggable('likelihood')) && !(showFeedback && allCorrect)" class="normal-div">
<buton @click="submitClicked">Submit</buton>
</div>

  </div>
</script>

<script type="text/x-template" id="samples-chart-template">
<div style="position:relative; display:inline-block" class="samples-chart">

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated && counts" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
        <g v-for="x in xdomain">
          <rect v-for="countInd in counts[x]"
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x]) + yScaleBandwidth*(countInd-1)+2"
          :width="xScale.bandwidth()"
          :height="yScaleBandwidth-2"
          :key="x + countInd"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="chartHeight - yScale(counts[x]) - (isDraggable ? 8 : 2)">
        {{ counts[x] }}
      </text>

      <text v-if="showRatio"
        v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 8"
        :y="chartHeight + 40"
        fill="#bbb">
        {{ prob(x) }}%
      </text>

    </g>
</svg>

  <div v-for="x in xdomain" 
      v-if="isDraggable && counts"
      class="dot"
      style="position:absolute"
      draggable="true"
      @dragstart="dragstart(x)"
      @dragend="dragend"
      @drag="drag(x, $event)"
      :style="dotStyle(x)"></div>


</div>
</script>


<script type="text/x-template" id="buton-template">
<span style="margin-bottom:0px; position:relative; display:inline-block; vertical-align:top" class="normal-div">
  <div style="display:inline-block">
    <div v-if="showX" 
         class="handwriting" 
         style="display:inline-block; position:absolute; color:#777; font-size: 48px; left: calc(50% - 20px); top:-4px">X</div>
    <button 
      @click="butonClicked()" v-on="$listeners" 
      :class="{'clicked-button': clickedButton}" 
      class="handwriting"><slot></slot>
    </button>
  </div>

</span>
</script>


<script type="text/x-template" id="input-box-template">
<div style="display:inline-block; position:relative; top:-16px;" class="normal-div">

  <input v-model="val" placeholder="?" style="width:70px; display:inline; position:relative; top:16px" v-on:keyup.enter="answerSubmit">
  <span style="position:relative; top:12px"><slot></slot></span>
  <buton style="display:inline" @click="answerSubmit">Go</buton>

  <div v-if="showCannedHint" class="hint">
    {{cannedHint}}
  </div>
  <div v-if="showYay" class="rainbow-text">
    Yay!
  </div>


  <div v-if="showHintSlot" class="hint normal-div">
    <slot name="hint"></slot>
  </div>
</div>
</script>



<script type="text/x-template" id="next-template">
  <buton @click="next()"><slot></slot></buton>
</script>


<script type="text/x-template" id="intro-scene-template">
<pset>

  <div>
    <div>
      You have found yourself in front of a monastery...
    </div>
    <img src="images/monastery.png">
    <next>Next</next>
  </div>

  <div>
    A monk greets you.
    <img src="images/monk_big.png">
    <next>Next</next>
  </div>


  <div>
    <div>
      MONK: Hello, explorer....
    </div>

    <div>
    MONK: For years I have trained explorers like yourself to rid themselves of cognitive biases. Cognitive biases are instances in which humans consistently make irrational decisions. Would you like a lesson?
    </div>

    <next @click.native="$root.nextChapter()">Start lesson</next>
  </div>

</pset>

</script>


<script type="text/x-template" id="draggable-dist-template">
<div>

<!--  <div>beta({{betaA}} , {{betaB}})</div>
  <div>conf: {{conf}}</div>
  <div>mode: {{mode}}</div>
  <div>(dotLeft, dotTop): {{dotLeft}}, {{dotTop}}</div>
  <div>isDragging: {{isDragging}}</div> -->

<div class="draggable-dist" style="position:relative; border: 1px solid #ccc; display:inline-block">
  <canvas ref="canvas" width="500" height="150"></canvas>

  <div class="dot"
    v-if="!isDragging"
    style="position:absolute; background-color:#2F77A1"
    @mousedown="mousedown($event)"
    :style="redDotStyle"
    draggable="true"></div>    

  <!-- ghost red dot -->
  <div class="dot" v-if="isDragging"
    style="position:absolute; background-color:#2F77A1"
    @dragend="dragend"
    @drag="drag($event)"

    :style="ghostDotStyle"></div>    
</div>
</div>

</script>


<script type="text/x-template" id="inline-img-template">
  <img :src="'images/' + src" style="display:inline-block" :style="{height: height+'px'}">
</script>

<script type="text/x-template" id="beliefs-as-dists-template">
<pset ref="pset">


<!--<div>
<draggable-dist ref="dist" :guess1="34" :guess2="34"/>

<draggable-dist ref="dist" :guess1="150" :guess2="300"/>
<draggable-dist ref="dist" :guess1="4" :guess2="5"/>
<draggable-dist ref="dist" :guess1="24" :guess2="65"/>
<draggable-dist ref="dist" :guess1="12" :guess2="15"/> humm the shape isn't right for hte cat hours:
</div> -->


<div>
  <p>
  MONK: You should probably sit down.
  </p>
  <next>Sit</next>
</div>

<div>
  <p>
  MONK: I have been in search for my successor for a long time. The prophecy says that today is the last possible day for us to meet.
  </p>
  
  <next>Next</next>
</div>

<div>

  <img src="images/world.png" style="width:200px; margin:0 auto; margin-bottom:16px">

  <p>
  MONK: The world is in danger.
  </p>

  <p>
    Through the <a href="//en.wikipedia.org/wiki/Bystander_effect" target="_blank">Bystander Effect</a> we have been sitting by the side and watching as a few entities heat up the world and knock systems out of a precarious balance.
  </p>
  
  <next>Next</next>
</div>


<div>
  <p>
  The prophecy says that my successor is a tortured soul who will face a perilous journey to rid themselves of 13 biases or so and change the way how others see the world.
  </p>
  <next>13?!?!</next>
</div>

<div>
  <p>
    MONK: The prophecy actually thought 88 was more likely, but I thought it would be better to reduce it to 13 or else I'd never find anyone. 
  </p>

  <p>
    But before we worry about the biases of other people, let's work on the ones within ourselves. 
  </p>

  <next>Oh dear</next>
</div>



<div>
<div style="font-size:24px" class="handwriting">Magic Answer Fallacy</div>

<div>
The first bias is so pervasive, that it's not formally recognized as a cognitive bias. I call it the <bold>Magic Answer Fallacy</bold>. 
</div>

<div>
It's the tendency to respond to questions with a simple "magic answer".
</div>
<next>Next</next>
</div>

<div>
<div>
For instance, how many days are in a year? 
</div>

<div>
Most people would just say 365. But the true length of a year on Earth is ~365.2422 days. That is why we have leap years, but even leap years don't fully account for it.
</div>
<next>Next</next>
</div>


<div>
<div>
MONK: The first step is to accept that most questions don't have magic answers. Most answers are uncertain, and to capture the uncertainty we draw it as a distribution.
</div>

<p>A <bold>distribution</bold> has the possibilities on the x-axis and the probabilities on the y-axis. Consider these distributions from the prophecy.</p>
<next>Next</next>
</div>

<div>
  <p>Our hero will likely face a very large number of cognitive biases in their quest... but possibly only 13!</p>
  <div>
    <distribution :outcomes="[{x: 13, y: 0.1}, {x: 88, y: 0.5}, {x: 108, y: 0.2},]" xLabel="Number of biases hero needs to overcome" yLabel="Probability" />
  </div>
  <next>Gee</next>
</div>

<div>
  <div>
    Our hero is in search of a guide... who will likely be human, but may very well be animal or inanimate.
  </div>
  <div>
  <distribution :outcomes="[{x: 'human', y: 0.6},{x: 'animal', y: 0.2}, {x: 'book', y: 0.2},]" xLabel="Who will be the hero's guide?" yLabel="Probability" />
  </div>
  <next>Okay...</next>
</div>

<div>
<div>
MONK: This point is, distributions allow us to shift from using vague language like "pretty sure", to having a picture of exactly what we think.
</div>

<div>
Now, begin thinking in distributions instead of magic answers. 
</div>

<next>Begin</next>
</div>


<div>
  <p>
    Answer this question to the best of your ability.
  </p>

  <dist-question :question="questions[0]" @done="nextQuestion($event); $refs['pset'].next()">

    Question 1 out of {{questions.length}}.

    <template v-slot:tutorial>
      <div class="smaller-children">
        <div>
          Drag down the circle so that the distribution covers all answers that you think are reasonable. You can also drag the circle left and right to fine-tune the shape. This diagram is your <bold>belief graph</bold>. 
        </div>

        <div>
            You will earn wisdom credits with the monk based on the height of your graph over the magic answer <inline-img src="grad.jpg" :height="16" />.
        </div>

        <div>
          But to add some stakes in the game, if you assign 0 probability to the magic answer, you will have to do the dishes <inline-img src="dishes.png" :height="16" />.
        </div>
      </div>
    </template>
  
  </dist-question>
</div>

<div>
  <dist-question 
    v-for="(question, index) in questions" v-if="showGame && index !=0 && index <= questionInd" :question="question"
    :key="question.text"
    @done="nextQuestion($event)">
    Question {{index + 1}} out of {{questions.length}}.
  </dist-question>
</div>

<div>
  <p>
    Thank you for washing {{dishDuty}} days of dishes <inline-img src="dishes.png" />. Together, with your {{$root.roundTo(gradUnits, 1)}} wisdom points <inline-img src="grad.jpg" />, I think you should be allowed to proceed.
  </p>

  <next>Next</next>
</div>

<div>
  <p>
  MONK: I'm still uncertain whether you or one of the 20 adventurers before you is destined to be my successor. But to aid my decision would you be so kind as to seek out a figure named Kahneman? He can administer a test of your abilities.
  </p>
  <p>
  MONK: His whereabouts have been unknown for some time, so good luck finding him.
  </p>
  <next @click.native="$root.nextChapter()">Leave the monastery</next>
</div>

</pset>
</script>

<script type="text/x-template" id="bayes-unit-template">
<div>

<div ref="panes" style="position:fixed; top:50px; left: 0px; font-size:14px; background-color:rgba(255,255,255,0.97); width: 555px; z-index:1;">

    <div v-if="knowAbout('location')" 
         @click="togglePane('location')" 
         class="bayes-toggle"
      style="position:absolute; left: -100px;top:100px">
      <div ref="location-toggle" 
        :style="toggleStyle('location')" style="transform:rotate(-90deg); display:inline-block; font-weight:700; width:400px;">
          Belief: Kahneman's location?
          <inline-img src="cave.png" />
          <inline-img src="tavern.png" />
        </div>
    </div>

    <div v-if="knowAbout('food')"
         class="bayes-toggle"
         @click="togglePane('food')" 
         :style="toggleStyle('food')" 
      style="position:absolute; left: -130px;top:100px">
      <div ref="food-toggle" style="transform:rotate(-90deg); display:inline-block; font-weight:700; width:400px;">
        Belief: Food to bring?
        <inline-img src="beer.gif" />
        <inline-img src="cookies.jpg" />
      </div>
    </div>

    <keep-alive>
       <triple-bayes v-if="showPane('food')" key="food" style="position:relative; left:120px; top:20px; padding-bottom:24px; background-color:white;"
        :hypotheses="['Beer', 'Cookies']" 
        :config="{prior: {dist: [2, 5], isActive:true}, likelihood: {dist: [1, 1], correct: [1, 2],  isActive: true, isDraggable:true}, posterior: {isActive: true}}"
        :colors="{bar: '#CB9C44', dot: '#FC8E03'}"
        @yay="activePane=null; $refs['pset'].next()"></triple-bayes> 
    </keep-alive>

    <keep-alive>
       <triple-bayes v-if="showPane('location')" key="location" style="position:relative; left:120px; top:20px; padding-bottom:24px; background-color:white;"
        :hypotheses="['Cave', 'Tavern']" 
        :config="{prior: {dist: [2, 3], isActive:true}, likelihood: {dist: [1, 1], correct: [3, 1], isActive: true, isDraggable:true}, posterior: {isActive: true}}"
        :colors="{bar: '#D8D8D8', dot: '#2F77A1'}"
        @yay="activePane=null; $refs['pset'].next()"></triple-bayes> 
    </keep-alive>


</div>

<pset ref="pset">


<div>
<p>
  You have found yourself on a solo journey across the land to gain knowledge and find Kahneman.
</p>
<p>
  You decide to seek help from the oracle on top of the mountain. 
</p>
<next>Climb the mountain</next>
</div>

<div>
<img src="images/mountain.gif">
<p>
  It takes you days and days to climb to the peak of the mountain...
</p>
<next>And days</next>
</div>

<div>
<p>
  And days....
</p>
<next>And days</next>
</div>

<div>
<p>
  And even more days....
</p>
<next>And days</next>
</div>

<div>
<p>
  But you finally make it.
</p>
<next>Oh good</next>
</div>

<div>
<p>
  ORACLE: So, you're searching for Kahneman? 
</p>

<img src="images/oracle.png">

<p>
  The oracle peers into your eyes. 
</p>
<next>Peer back</next>
</div>

<div>
<p>
ORACLE: Well, I could tell you where he is but that would defeat the point. 
</p>

<p>
  ORACLE: Instead, I will give you hints about where he is and you have to combine the hints to form your best guess. 
</p>

<p>
  ORACLE: Do you understand?
</p>

<next>Yes, I think so?</next>
</div>


<div>
<h3 style="font-weight:700">Oracle Lesson: Update beliefs</h3>
<p>
  ORACLE: Based on past experience, Kahneman is likely either at the Cave of Uncertainty or the Tavern of Decision-Making. Unfortunately, these places are weeks of travelling away from each other, so you will want to be reasonably certain before embarking.  
</p>

<img src="images/cave.png" width="200px" style="display:inline-block"> <img src="images/tavern.png" width="200px" style="display:inline-block">
<br>
<next>How do I know which to go to?</next>
</div>


<div>
<p>
  ORACLE: Well, Kahneman goes to the tavern to study people's decision-making abilities. He goes to the cave to process his data and write papers. In the past Kahneman has split his time between the cave and the tavern in a roughly 2 to 3 ratio (40% vs 60%).
</p>

<p>
  ORACLE: You can use this information to create a visual picture of your knowledge. Drag the circles until the bar heights reflect what you currently know about Kahneman's location.
</p>

<triple-bayes 
:hypotheses="['Cave', 'Tavern']" 
:config="{prior: {isActive: true, isDraggable:true, dist: [1, 1], correct: [2, 3], title: 'Belief about Kahneman\'s location', subtitle:''}}"
:colors="{bar: '#D8D8D8', dot: '#2F77A1'}"></triple-bayes>
</div>

<div>
<p>
  ORACLE: Correct. This picture is called your <bold>prior belief</bold>.
</p>
<p>
  ORACLE: Without any additional information, the probability of Kahneman being at either location is shown by this graph. Looking at the heights of the graph, you can visually see that he is 50% more likely to be at the tavern.
</p>
<next>I see how the bar heights represent relative probabilities</next>
</div>

<div>
<p>
  Suppose that the weather has been nice recently, and someone tells you that when the weather is nice Kahneman is more likely to prefer going to the cave than spending all day in a tavern. 
</p>

<img src="images/good_weather.jpg" width="200px">
<br><br>
<next>This new information should change my mind</next>
</div>

<div>
<p>
 If the weather is nice, say Kahneman favors going to the cave over the tavern six times more than normal. Incorporate this new <bold>evidence</bold> into you belief by dragging up the evidence bars. 
</p>

<triple-bayes 
  :hypotheses="['Cave', 'Tavern']" 
  :config="{prior: {dist: [2, 3], title: 'Prior belief', subtitle:'Base rate on Kahenman\'s location'}, likelihood: {dist: [1, 1], correct: [6, 1], isActive: true, isDraggable: true, subtitle:'Relative likelihood of good weather'}}"
  :colors="{bar: '#D8D8D8', dot: '#2F77A1'}"></triple-bayes> 

</div>

<div>
<p>
It turns out that the evidence bars should <bold>multiplicatively scale</bold> up your prior belief to form your <bold>new belief</bold>. This relationship is called the odds ratio form of Bayes Rule. This multiplication is something you can perform with your visual system. 
</p>
<next>Show new belief</next>
</div>

<div>
<triple-bayes 
:hypotheses="['Cave', 'Tavern']" 
:config="{prior: {dist: [2, 3]}, likelihood: {dist: [6, 1], correct: [6, 1]}, posterior: {isActive: true}}"
:colors="{bar: '#D8D8D8', dot: '#2F77A1'}"></triple-bayes> 

<p>
What is the probability that Kahneman is in the cave if the weather is nice?
</p>
<input-box right="80">%</input-box>
</div>


<div>
<p>
ORACLE: Very nice. Often times, information about our world comes in multiple parts. We have to combine these parts to form a unified belief. Logic tells you how to do this.
</p> 

<p>
ORACLE: Pretend that you are a detective. 
</p>

<img src="images/detective.png" height="150">

<p>
ORACLE: During a case you discover some new evidence. What you think after obtaining new evidence should depend both on </p>
<p>
(a) <bold>what you previously believed</bold> and (b) <bold>the new evidence</bold>. 
</p>

<next>Pretty intuitive</next>
</div>

<div>

<p>
These two parts go by other names including
</p>
<p>
(a) <bold>prior belief</bold> and (b) <bold>likelihood of evidence</bold>. 
</p>

<p>
When making guesses, sometimes people use the new evidence and forget to include their prior knowledge, this is called <a href="http://en.wikipedia.org/wiki/Base_rate_fallacy" target="_blank">Base Rate Neglect</a>. Sometimes they stick too firmly to prior knowledge and forget to include the evidence, this is called <a href="http://en.wikipedia.org/wiki/Conservatism_(belief_revision)" target="_blank">Bayesian Conservatism</a>. 
</p>

<next>Sounds reasonable</next>
</div>

<div>
<p>
As long as you use the widget I have given you, you will remember to use both your prior belief and the likelihood of evidence to form your new opinion.
</p>

<p>
Take this widget into your sidebar so that you can update your beliefs on Kahneman's location as you get new information.
</p>

<p>
At this point, all you have is the 2:3 prior on Kahneman's location. The weather evidence was hypothetical.
</p>

<next @click.native="knowAboutArr.push('location')">Take the widget</next>
</div>


<div>
  <img src="images/forest.jpg" height="300">

  <p>
    You descend the other side of the mountain into a dark forest.
  </p>

  <next>Enter the forest</next>
</div>

<div>
  <p>
    A shadowy figure approaches you. 
  </p>
  <img src="images/monk.gif">

  <p>
    SHADOW FIGURE: You have an unusual power of inference about you. I do too and infer that you are looking for someone.
  </p>

  <next>I am looking for Kahneman. Do you know where he is?</next>
</div>


<div>
  <p>
    SHADOW FIGURE: Ha! Well, I don't know where he is. 
  </p>

  <p>
    SHADOW FIGURE: But I've searched for him in the past, and you also need a Thing.  
  </p>

  <next>A thing?</next>
</div>

<div>
  <p>
  SHADOW FIGURE: Well, he doesn't take visitors easily. You want to take the test of your abilities, I assume. 
  </p>

  <p>
  SHADOW FIGURE: But usually you can't get him to see you just by declaring that. I would suggest either saying that you are selling cookies or that you are selling beer. You need to infer which type of food he is interested in before you see him. 
  </p>

  <img src="images/cookies.jpg" width="200px" style="display:inline-block"><img src="images/beer.gif" width="200" style="display:inline-block"><br>

  <next>Why can't I just offer him both beer and cookies?</next> 
</div>

<div>
  <p>
  SHADOW FIGURE: Because it's part of the test to infer what he likes!
  </p>

  <next>Okay... can you tell me the prior belief I should have over beer and cookies?</next>
  </div>

  <div>
  <p>
  SHADOW FIGURE: Ah, I see you have been trained by the Bayesian Oracle. 
  </p>

  <p>
  SHADOW FIGURE: Well prior beliefs are a bit subjective, but I would say that for most people, you should expect 2 : 5 beer versus cookies (29% vs 71%).
  </p>

  <p>
  SHADOW FIGURE: After all, who doesn't like cookies?
  </p>

  <next @click.native="knowAboutArr.push('food')">Add the picture to your mental beliefs</next>
</div>

<div>
  <p>
  You attempt to thank the shadowy figure, but he has vanished.
  </p>

  <next>Creepy... let's get out of this forest.</next>
</div>


<div>
  <img src="images/village.png" width="300">
  <p>
  You have made it out of the shadow forest and into the neighboring town. You are still over a week of journeying from both the tavern and the cave.
  </p>
  <next>Enter the town</next>
</div>

<div>
  <img src="images/farmer.png" height="300px">
  <p>
  And there is a somewhat distressed looking farmer on the side of the road.
  </p>
  <next>Ask her what's wrong</next>
</div>


<div>
  <p>
  FARMER: There have been thefts from my chicken coop. The local animal population consists of 7 raccoons to every 3 foxes (70% raccoons, 30% foxes). Judging by the type of marks on the door alone, the marks look five times more likely to be caused by a fox than a raccoon.
  </p>

  <p>
  FARMER: I want to trap the animal, but I only have traps for foxes. If a raccoon goes in, it will get hurt. If I set up the trap, what is the probability that the animal I will catch will be a fox?
  </p>

  <p class="question">
  Show the farmer the appropriate new belief.
  </p>

  <triple-bayes 
  :hypotheses="['Raccoon', 'Fox']" 
  :config="{prior: {dist: [1, 1], correct: [7, 3], isActive: true, isDraggable:true}, likelihood: {dist: [1, 1], correct: [1, 5], isActive: true, isDraggable: true}, posterior: {isActive:true}}"
  :colors="{bar: '', dot: '#EF6D21'}"></triple-bayes>
</div>

<div>
  <p>
  FARMER: So what is the numerical probability that it will be a fox?
  </p>
  <input-box right="68">%</input-box>
  </div>

  <div>
  <p>
  FARMER: Wow, thanks a lot, traveller! 
  </p>

  <p>
  FARMER: Can I invite you home for breakfast?
  </p>

  <next>You haven't eaten for over 40 clicks. Go eat with the farmer!</next>
</div>

<div>
  <p>
  You realize that you have been happily staring off into space thinking about Bayes Rule that you have been a pretty lousy meal companion. After a hearty homecooked meal, the farmer hints that you should continue on your way.
  </p>

  <next>Have you seen any other travellers around who I could talk to?</next>
  </div>

  <div>
  <p>
  FARMER: You should see the mayor. His office is yonder.
  </p>

  <next>Head toward the mayor's office</next>
</div>


<div>
<img src="images/thinking-man.jpg" width="300">

<p>
It's a small town so you are able to walk straight into the mayor's office. The mayor is rubbing his chin with a furrow on his brow.
</p>

<next>Talk to the mayor</next>
</div>

<div>
<img src="images/trebuchet.png">
<p>
MAYOR: I am trying to choose the better builder for the town rock throwing machine. The two builders in the town are Billy and Bob. 60% of the time Billy's quality is better than Bob's. However, when I met with both of them... Bob showed me a prototype that looked twice as good as Billy's. What is the probability that excited Bob will produce the better result on this project?
</p>
<next>I think I can help</next>
</div>

<div>

<p class="question">
Show the mayor the appropriate belief.
</p>

 <triple-bayes 
  :hypotheses="['Billy', 'Bob']" 
  :config="{prior: {dist: [1, 1], correct: [3, 2], isActive: true, isDraggable:true}, likelihood: {dist: [1, 1], correct: [1, 2], isActive: true, isDraggable: true}, posterior: {isActive:true}}"
  :colors="{bar: '#ccc', dot: '#D6732A'}"></triple-bayes>
</div>

<div>
<p>
MAYOR: So what is the probability that Bob will do a better job than Billy?
</p>
<input-box right="57">%</input-box>
</div>

<div>
<p>
MAYOR: Hey, thanks, adventurer!
</p>

<p>
MAYOR: You're not from around these parts are you?
</p>

<p>
You tell the Mayor that you're searching for Kahneman or other travellers who might know of his whereabouts.
</p>

<p>
MAYOR: Oh Kahneman? So many people have been looking for him these days. 
</p>
<next>Do you know where he is?</next>
</div>



<div>
<p>
MAYOR: NOPE.
</p>
<next @click.native="highlight('food-toggle')">Do you know if he likes beer or cookies?</next>
</div>

<div data-checkpoint="mayor-cookies">
<p>
MAYOR: Cookies. Definitely cookies. 
</p>

<p>
MAYOR: I'd say that he likes cookies 2 times more than the average person. And he's about average for beer. 
</p>

<p class="question">
Use the mayor's information to update your beliefs about Kahneman.
</p>

</div>

<div>
<p>
You thank the mayor and wish him best of luck with his rock thrower. 
</p>
<next>Keep journeying</next>
</div>

<div>
<p>
As you journey through villages, acquiring the goodwill of all you meet through your powers of rational inference, news begins to spread about you. 
</p>

<next>Keep a moderate head so as not to succumb to the overconfidence bias</next>
</div>

<div>
<p>
An adventurer approaches you.
</p>
<img src="images/adventurer.png" width="200">
<p>
ADVENTURER: I hear you are looking for Kahneman.
</p>
<p>
ADVENTURER: I am 99% sure that Kahneman is at the cave of uncertainty!
</p>
<next @click.native="highlight('location-toggle')">Oh dear, he probably hasn't been through Magic Answer training</next>
</div>

<div data-checkpoint="kahneman-loc-man">
<p>
You talk to the adventurer in attempt to find out his intentions. He seems to have no ill wishes to you. 
</p>

<p>
Discounting for his questionable reliability, you think that it is more reasonable to assume that the man is correct with 75% probability (3 : 1) instead of 99% (99 : 1). 
</p>

<p class="question">
Use the adventurer's information to update your belief on Kahneman's location.
</p>
</div>

<div>
<p>
You think that Kahneman is probably at: <br>
<next>The Cave</next>
<buton nope>The Tavern</buton>
</p>
</div>

<div>
<p>
And you think that you might want to bring some:<br>
<buton nope>Beer</buton>
<next>Cookies</next>
</p>
</div>

<div>
<p>
You shift course and proceed directly to Picabo's Cookie Store.
</p>
<next>Go forth</next>
</div>

<div>
<img src="images/cave.png" width="450px">
<p>
After almost a week, you make it to the cave with peanut butter cookies in hand....
</p>
<next>Enter the cave</next>
</div>

<div>
<p>
"Hello, Kahneman?" you venture tentatively. 
</p>
<next>Wait for a response</next>
</div>

<div>
  <p>
  The sound of your voice echoes deep into the cave. The walls of the cave begin to shudder and hiss. The walls begin to fold in, and you are suddently uncertain that this was truly the Cave of Uncertainty. 
  </p>

  <next @click.native="$root.nextChapter()">Next</next>
</div>

</pset>
</div>
</script>

<script type="text/x-template" id="moneybag-question-template">
<div>

  <div><slot></slot>{{question.text}}</div>

  <once-group>
    <buton v-for="choice in question.choices" :key="choice" @click.native="userChoice = choice">{{choice}}</buton>
  </once-group>

  <div v-if="userChoice">
    <div>
    And, how sure are you about your answer?
    </div>

    <once-group>
      <buton v-if="viz=='certainty'" 
             v-for="certainty in certainties"  
             :key="certainty" 
             @click="finishQuestion(certainty)">{{certainty*100}}%</buton>

      <buton v-if="viz=='moneybag'" 
              v-for="numLoseIfWrong in numLoseIfWrongs" :key="numLoseIfWrong"
              @click="finishQuestion($root.paramsFromBet(1, numLoseIfWrong).certainty)">
        <fair-bet  
        :numLoseIfWrong="numLoseIfWrong"></fair-bet>
      </buton>
    </once-group>
  </div>

  <transition name="fade"><div>{{userFeedback}}</div></transition>
</div>
</script>


<script type="text/x-template" id="dist-question-template">
<div>

  <div><bold><slot></slot></bold> {{question.text}}</div>

  <input-box @click="guessSubmitted" :advancePset="false" :min=
  "0" :max="question.maxBound"></input-box>

  <div v-if="stage > 0">
    <p>
      If you had to make a second guess, what would it be?
    </p>
    <input-box @click="secondGuessSubmitted" :advancePset="false" :min="0" :max="question.maxBound"></input-box>
  </div>


  <div v-if="stage > 1">
    <slot name="tutorial"></slot>

    <once-group>
      <draggable-dist ref="dist" :guess1="guess1" :guess2="guess2" :maxBound="question.maxBound" />
      <buton @click="beliefSubmitted">Submit belief</buton>
    </once-group>
  </div>

  <div v-if="stage > 2">
    <div>
      The magic answer was {{question.answer}}. The height of the magic answer on your normalized belief graph was {{$root.roundTo(guessHeight, 5)}}.
    </div>

    <div v-if="result.gradUnits">
      You accumulate {{$root.roundTo(result.gradUnits, 1)}} wisdom points <inline-img src="grad.jpg" />. 
    </div>

    <div v-if="result.dishDuty">
      Thereby you will be washing dishes for {{result.dishDuty}} night <inline-img src="dishes.png" />.
    </div>
  
    <buton @click="finishQuestion">Onwards</buton>
  </div>

</div>
</script>



<script type="text/x-template" id="overconfidence-template">
<pset ref="pset">

<!-- <moneybag-question 
  :question="certaintyBundle.questions[0]"
  viz="certainty">
</moneybag-question> -->


<div>
<img src="images/cave.png">

<p>
You were standing alone in a cave holding a scroll and calling out for Kahneman... when the cave mysteriously started shrinking and the walls closed in.
</p>

<p>
The walls are now uncomfortably close around your chest and vital organs.
</p>

<next>Help!</next>
</div>

<div>
<img src="images/eyes.png" style="width:400px">

<p>
VOICE: Welcome to the Cave of Overconfidence.
</p>

<p>
VOICE: You boldly waltzed in thinking you had it figured out. But did you know that most humans are overconfident?
</p>

<next>I'm sorry</next>
</div>


<div>
<p>
VOICE: When humans say they are 70% sure, it turns out that you're only 50% right.
</p>

<p>
VOICE: 93% of human drivers think they are above average.
</p>

<p>
VOICE: And one human grossly underestimated the amount of time it would take them to write the next chapter of Adventures in Cognitive Biases. 
</p>

<p>
VOICE: I'm tired of all these little lies humans tell eachother and themselves.
</p>

<next> Who are you? Please let me go.</next>
</div>


<div>
<p>
VOICE: I'll let you go... for a price. 
</p>

<p>
VOICE: How many cookies do you have on you? 
</p>

<next>Five cookies</next>
</div>

<div>

<p>
The voice chuckles.
</p>

<p>
VOICE: I was thinking more on the order of... fifty cookies.
</p>

<next>But I don't have that many</next>
</div>

<div>
<p>
You can bet with me to earn more cookies...
</p>

<p>
But if you lose, *walls narrow*.... well, you don't want to happen. 
</p>

<next>Oh no</next>
</div> 


<div>
<p>
I will ask you some questions. But more importantly, I will ask you how sure you are of your answer.  
</p>

<p>
  Answer these {{certaintyBundle.questions.length}} questions to see how you do without any calibration.
</p>

<moneybag-question 
  v-for="(question, index) in certaintyBundle.questions" 
  v-if="index <= certaintyBundle.questionInd" 
  :question="question"
  :key="question.text"
  viz="certainty"
  @done="nextQuestion($event, certaintyBundle)">
  <bold>Problem {{index + 1}} out of {{certaintyBundle.questions.length}}: </bold>
</moneybag-question>
</div>

<div>
  <p>
  On average, you were {{certaintySureness}}% sure. And on average, you were {{certaintyAccuracy}}% accurate.
  </p>

  <p v-if="certaintySureness > certaintyAccuracy + 10">
    You're a typical human, with more certainty than accuracy.
  </p>
  <p v-else-if="certaintySureness  + 10 < certaintyAccuracy">
    How unusual.... you were less certain than you were accurate. 
  </p>
  <p v-else>
    This is indeed pretty impressive for a human. You are reasonably calibrated. You may not need this following tool, but humor me. 
  </p>

  <next>Next</next>
</div>

<div>
<p>
To better calibrate your certainty, think in terms of the fair bet instead. 
</p>

<p>
For instance, the bet:
</p>

<fair-bet :showCertainty="false" style="padding: 8px" />

<p>
Corresponds to 50% certainty, because if you are correct 50% of the time, this bet would break even.
</p>

<next>Hm...</next>
</div>

<div>
<p>
The bet:
</p>

<fair-bet :numLoseIfWrong="4" :showCertainty="false" style="padding: 8px" />

<p>
Corresponds to 80% certainty, because if you are correct 80% of the time, this bet would break even.
</p>

<next>I think I see the relationship between fair bets and certainty</next>
</div>

<div>

<p>
Try it here...
</p>

<moneybag-question 
  :question="moneybagBundle.questions[0]"
  viz="moneybag"
  @done="logFirstMoneybagQuestion">
  <bold>Problem 1 out of {{moneybagBundle.questions.length}}: </bold>
</moneybag-question>
</div>

<div>
<p>
Since you were {{firstMoneybagPayout > 0 ? 'correct' : 'incorrect'}}, you {{ firstMoneybagPayout > 0 ? 'win' : 'lose'}} {{firstMoneybagPayout}} moneybags. 
</p>

<next>Why don't I always pick 50%</next>
</div>

<div>
<p>
Reader, you should answer honestly. If the cave detects any dishonesty, *cave walls close in menancingly*.
</p>

<next>I'm ready</next>
</div>

<div>
<moneybag-question 
  v-for="(question, index) in moneybagBundle.questions" 
  v-if="index > 0 && index <= moneybagBundle.questionInd" 
  :question="question"
  :key="question.text"
  viz="moneybag"
  @done="nextQuestion($event, moneybagBundle)">
  <bold>Problem {{index + 1}} out of {{moneybagBundle.questions.length}}: </bold>
</moneybag-question>
</div>

<div>

<p>
  This time, on average, you were {{moneybagSureness}}% sure. And on average, you were {{moneybagAccuracy}}% accurate.
</p>

<p v-if="improvement > 10">
  It seems like you're better calibrated than before...
</p>
<p v-if="improvement < 0">
  It seems like you're worse off than before... The mysterious voice sighs.
</p>
<p v-else>
  It seems like you're about the same as before. The mysterious voice sighs.
</p>

<next>Next</next> 
</div>

<div>
<p>
Out of the darkness steps...
</p>

<next @click.native="$root.nextChapter()">Could this be Kahneman?</next>
</div>

</pset>
</script>

<script type="text/x-template" id="once-group-template">
<div :class="{disabled: isClicked}"><slot></slot></div>
</script>


<script type="text/x-template" id="moneybag-template">
<span style="position:relative; display:inline-block;">
  <img v-for="n in Math.ceil(number)" 
       :style="{width: width+'px', display: isHorizontal ? 'inline-block': 'block'}" 
       style="margin-right:2px"
       src="images/cookie.png">

  <!-- cover up to make a fractional moneybag -->
   <span v-if="positiveFraction > 0.01"
         style="background-color:rgb(255,255,255,0.8); position:absolute; right: 0px; bottom:4px;" 
         :style="fractionalCoverStyle"></span>
</span>

</script>

<script type="text/x-template" id="fair-bet-template">

<div class="small-text normal-div fair-bet" style="text-align:left; user-select:none">

  <div>
    <div>Win if right ({{numWinIfRight}})</div>
    <moneybag :number="numWinIfRight"></moneybag>
  </div>

  <div>
    <div>Lose if wrong ({{numLoseIfWrong}})</div>
    <moneybag :number="numLoseIfWrong"></moneybag>
  </div> 

  <div v-if="showCertainty" style="text-align:center; margin-top:12px">
    <bold>{{ $root.paramsFromBet(numWinIfRight, numLoseIfWrong).percent }} sure</bold>
  </div>  
</div>

</script>


<script type="text/x-template" id="thanks-template">
<div class="thanks">

<p>
  <bold>To be continued...</bold>
</p>

<p>
The list of people to thank is very long: 
</p>

<p>
The original verison of this game was built as part of a masters thesis with the MIT Media Lab's Fluid Interfaces Group headed by Pattie Maes. Ideas in the game were also heavily influenced by two classes at MIT (9.660 by Prof. Josh Tenenbaum) and (6.437 by Prof. Lizhong Zheng). 
</p>

<p>
Many friends and advisors helped with early incarnations of this story... Among them were Dor Abrahamson, Ned Burnell, Yasemin Gokce, Cory Li and Ruwen Liu, Pattie Maes, Paul Medlock-Walton, Kelly Ran, Mitch Resnick, Jacob Steinhardt, BV, Victoria Xia, and Sophia Youn.
</p>

<p>
The backers and supporters of Ishaan's Journey, including Brienne and Eliezer Yudkowsky, Eric Chisholm, Alia McCutcheon and other folks from the LessWrong scene who encouraged me to develop this further and who were very patient with me as I took several unnecessary detours. 
</p>

<p>
Nicky Case who helped nurture an amazing community around explorable  explanations, and created multiple examples for how to make experiences both fun + educational. Spencer Greenberg and Mike Mozer who kept the project alive through their enthuasism and insightful critique on the original version. And thank you to all the folks who emailed in with encouragement and offers to help. 
</p>

<p>
Anand Babu and Google Kernel friends that provided a safe space and the final push of energy to rewrite this story. Fred Bertsch and Vivek Sri who helped massage the story. Tianyu Liu for always recommending inspirational prior work. Nathan Martz, the oracle that was right about all the pitfalls.
</p>

<p>
On the tech side, Vue.js greatly simplified the code needed for this project, and actually made it pleasant to write. And jpegslayer who helped me on the friendly Vue forums.
</p>

<p>
If you'd like to submit feedback or buy the monk a coffee, both would be very appreciated!
</p>


</div>
</script>

<!-- end templates -->


<script>
// lightblue = #D1D9E0
// darkblue = #2F77A1
const DEBUG = false;


var sounds = {

  // 'buton': {clip: new Audio('sounds/237422__plasterbrain__hover-1.mp3')},
  // 'nope': {clip: new Audio('sounds/423169__plasterbrain__pc-game-ui-error.mp3')},
  // 'yay': {clip: new Audio('sounds/242855__plasterbrain__friend-request.mp3')},

  'open': {clip: new Audio('sounds/swish0.wav')},
  'close': {clip: new Audio('sounds/swish1.wav')},
};



const numericQuestions = [
{
  text: 'How many hours does an average cat sleep in a day?',
  answer: 16,
  maxBound: 24,
},
{
  text: 'What percent of total electricity consumption goes to refrigerators?',
  answer: 7,
  maxBound: 100,
},
{
  text: 'How many countries are there in the world?',
  answer: 196,
},
{
  text: 'What percent of the population is left handed?',
  answer: 10,
  maxBound: 100,
},
{
  text: 'What is the estimated age of the universe in billions of years?',
  answer: 13.75,
},
{
  text: "What percent of the body's nutrients is consumed by the brain?",
  answer: 25,
  maxBound: 100,
},
{
  text: 'How many bones are there in the human body?',
  answer: 206,
},
{
  text: 'How many kilometers tall is Mt. Everest?',
  answer: 8.8
},
];

// main source: 'https://www.rd.com/culture/interesting-facts/'
// https://bestlifeonline.com/random-fun-facts/
const certaintyQuestions = [
{
  text: 'Which has the greater population?',
  choices: ['Hyderabad', 'Islamabad'],
  answer: 'Hyderabad',
}, 

{
  text: 'What color was the orange fruit when it was first developed?',
  choices: ['green', 'red'],
  answer: 'green',
}, 

{
  text: 'John Chapman (the real life Johnny Appleseed) planted thousands of apple trees, but they were too...?',
  choices: ['sour', 'bitter'],
  answer: 'bitter',
},

{
  text: 'How many words does Scotland have for snow?',
  choices: [42, 421],
  answer: 421,
},

{
  text: "A cashew is not technically a nut, because a nut is a 'hard-shelled dry fruit or seed with a separable rind or shell and interior kernel'. A cashew is actually a...",
  choices: ['legume', 'seed'],
  answer: 'seed',
},

{
  text: 'The longest English word is how many letters long?',
  choices: [819, 189819],
  answer: 189819
},

];

const moneybagQuestions = [
{
  text: 'How many calories are consumed by a blue whale in one mouthful?',
  choices: [50000, 500000],
  answer: 500000,
},

{
  text: 'What is the tiny pocket in jeans meant to store?',
  choices: ['Watch', 'Coins'],
  answer: 'Watch',
}, 

{
  text: "President Theodore Roosevelt had which of these as a pet?",
  choices: ['owl', 'moose'],
  answer: 'owl',
},

{
  text: "Where is the world's largest desert?",
  choices: ['Africa', 'Antarctica'],
  answer: 'Antarctica',
},

{
  text: "Which two body parts keeps growing as we reach late adulthood?",
  choices: ['Ears and nose', 'Teeth and liver'],
  answer: 'Ears and nose',
},

{
  text: "Pigeon poop was used to make what item?",
  choices: ['paint', 'gun powder'],
  answer: 'gun powder',
},

{
  text: "Nikola Tesla disliked what type of jewelry?",
  choices: ['silver', 'pearls'],
  answer: 'pearls',
},

{
  text: "What is the most popular instrument in North Korea?",
  choices: ['flute', 'accordion'],
  answer: 'accordion',
},

];


const wait = ms => new Promise(resolve => setTimeout(resolve, ms));


// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();


Vue.component('next', {
  methods: {
    next(){
      const pset = firstAncestorOfComponent(this, 'pset');
      if (pset){
        pset.next();
      }      
    }
  },
  template: '#next-template'
});


Vue.component('input-box', {
  props: {
    right: {type: String},
    hints: {
      type: Array, 
      default: function(){ return ['Try again', 'Nope']; },
    },

    advancePset: {type: Boolean, default: true},
    min: {type: Number},
    max: {type: Number},
  },
  computed: {
    isValid(){
      const passMinCheck = this.min === undefined || (this.numericVal && this.numericVal >= this.min);
      const passMaxCheck = this.max === undefined || (this.numericVal && this.numericVal <= this.max);
      return passMinCheck && passMaxCheck;
    },
    validationErrorString(){
      if (this.min === undefined){
        return 'Value must be less than or equal to ' + this.max + '.';
      }
      if (this.max === undefined){
        return 'Value must be greater than or equal to ' + this.min + '.';
      }
      return 'Value must be between ' + this.min + ' and ' + this.max + '.';
    },
    cannedHint(){
      if (!this.isValid){
        return this.validationErrorString;
      }
      return this.hints[this.answers.length % this.hints.length];      
    },
    numericVal(){
      try{
        return Number(this.val);        
      } catch {
        return null;
      }
    },
    isYay: function(){
      return this.right && this.isMatch(this.val, this.right);
    },
    isNope: function(){
      return this.right && !this.isYay;
    },
    showYay(){
      return this.checkedAnswer && this.isYay;
    },
    showCannedHint(){
      if (!this.checkedAnswer){
        return false;
      }
      if (!this.isValid){
        return true;
      }
      if (this.right === undefined){
        return false;
      }
      return !this.hasSlot('hint') && this.isNope;
    },
    showHintSlot(){
      return (DEBUG || this.checkedAnswer) && this.hasSlot('hint') && this.isNope;
    }
  },
  data: function(){
    return {
      val: null,
      answers: [],

      checkedAnswer: false,
    }
  },
  watch:{
    val(){
      this.checkedAnswer = false;
    }
  },
  methods: {
    isMatch(val, right){
      if (val === undefined || val === null){
        return false;
      }
      const exactMatch = val == right;
      const europeanCommaMatch = val.replace(',', '.') == right;
      var evalMatch;
      try {
        evalMatch = approx(eval(val), eval(right));
      } catch(err){
        evalMatch = false;
      }
      return exactMatch || europeanCommaMatch || evalMatch;
    },
    answerSubmit: async function(){

      this.checkedAnswer = true;        

      if (this.isValid){
        this.$emit('click', {val: this.val});        
        this.answers.push(this.val);
      }

      if (this.isYay){
        this.$root.play('yay');
        this.$emit('yay');

        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset && this.advancePset){
          pset.next();
        }
      }

      if (this.isNope) {
        this.$root.play('nope');
      }

    },
    hasSlot: hasSlot,
  },
  template: '#input-box-template'
});

function lerp(from_x, from_lo, from_hi, to_lo, to_hi){
  var scale = (to_lo-to_hi)/(from_lo-from_hi);
  return to_lo + (from_x-from_lo)*scale;
}

function firstAncestorOfComponent(node, componentName){
  while(node !== undefined){
    node = node.$parent;
    if (node !== undefined && node.$options.name === componentName){
      return node;
    }
  }
  return undefined;
}
function isDescendant(ancestor, maybeChild){

  // If maybeChild is a vue component
  var node = maybeChild.$parent;
  while(node !== undefined){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }

  // If maybeChild is an HTML element
  var node = maybeChild.parentElement;
  while(node !== null){
    if (node === ancestor){
      return true;
    }
    node = node.parentElement;
  }

  return false;
}

function hasSlot(name){
  return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
}


// Just like a button, but with some special abilities.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.
  },
  data: function(){
    return {
      clickedButton: false,
    }
  },
  computed: {
    nopeText: function(){
      if (this.nope){
        return this.nope;        
      }
      if (this.isNope){
        return 'Nope';
      }
    },
    // Returns true for: <buton nope> or <buton nope="why not">
    isNope: function(){
      return this.nope || this.nope==="";
    },
    isYay: function(){
      return 'yay' in this.$attrs;
    },
    showNopeText(){
      return (DEBUG || this.clickedButton) && this.isNope;
    },
    showRainbow(){
      return (DEBUG || this.clickedButton) && this.isYay;
    },
    showX(){
      return this.clickedButton && this.isNope;
    }
  },
  methods: {
    butonClicked: async function(){
      if (this.isYay){
        this.$root.play('yay');        
      } else if (this.isNope){
        this.$root.play('nope');
      } else{
        this.$root.play('buton');        
      }

      this.clickedButton = true;

      const onceGroup = firstAncestorOfComponent(this, 'once-group');
      if (onceGroup){
        onceGroup.childClicked();
      }

      // Add yourself to parent butonGroup's clicked children
      // so it can show feedback.
      const butonGroup = firstAncestorOfComponent(this, 'buton-group');
      if (butonGroup){
        butonGroup.clickedChildren.push(this);
      }

      // Move the screen along.
      if (this.isYay){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }        
      }
      this.$root.scrollWindow();

    },
  },
  template: '#buton-template'
});


// histogram example
// https://bl.ocks.org/d3noob/96b74d0bd6d11427dd797892551a103c
Vue.component('distribution', {
  props: {

    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    // Pass in outcomes directly.
    outcomes: {type: Array, default: function(){
      return [
        {x: 'tattoos', y: 0.2},
        {x: 'no tattoos', y: 0.8},
      ];
    }},
    chartHeight: {type: Number, default: 200},
    chartWidth: {type: Number, default: 300},
    barColor: {type:String, default:'#518891'},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 50, left: 50};
      }
    },
  },
  computed: {
    xScale(){
      return d3.scaleBand()
          .domain(this.outcomes.map(d => d.x)).paddingInner(0.01).range([0, this.chartWidth]);
    },
    xScaleContinuous(){
      const domain = this.xScale.domain();
      const range = this.xScale.range();
      const bandwidth = this.xScale.bandwidth();
      return d3.scaleLinear().domain([domain[0], domain[domain.length-1]]).range([range[0] + bandwidth/2, range[1] - bandwidth/2]);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, 1]).range([this.chartHeight, 0]);
    },
    titleStyle(){
      return {'margin-left': this.margin.left + 'px', 'margin-right': this.margin.right + 'px'};
    },
    mean: function(){
      return _.sum(this.outcomes.map(outcome => outcome.x * outcome.y));
    },
  },
  data: function(){
    return {
      isCreated: false,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: function() {
    // Add the axis
    var xAxis = d3.axisBottom(this.xScale); //.ticks(8);
    var yAxis = d3.axisLeft(this.yScale).ticks(4);

    const chart = d3.select(this.$el).select('.container');
    chart.append('g').call(yAxis);
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);


    // x axis label
    chart.append("text")             
      .attr("transform",
            "translate(" + (this.chartWidth/2) + " ," + 
                           (this.chartHeight + this.margin.top + 30) + ")")
      .style("text-anchor", "middle")
      .text(this.xLabel);

    // y axis label
    chart.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - this.margin.left)
      .attr("x",0 - (this.chartHeight / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text(this.yLabel);    

  },
  template: '#distribution-template'
});


Vue.component('inline-img', {
  props: {
    src: {type: String},
    height: {type: Number, default: 24},
  },
  template: '#inline-img-template'
});



function canvasPlotCoords(context, coords, fill){
  context.lineWidth = 1 / 600; //achtung!!! linewidth gets scaled
  context.strokeStyle = '#192127';
  context.fillStyle = fill;
  context.beginPath();

  var first = coords[0];
  context.moveTo(first[0], first[1]);
  coords.forEach(function (coord, ind){
    if (ind == 0){
      return;
    } 
    context.lineTo(coord[0], coord[1]);
  } );
  context.lineTo(first[0], first[1]);

  context.closePath();

  context.fill();
  context.stroke();     
}

function canvasAddText(context, text, coord, font){
  context.font = font;
  context.fillStyle = "black";
  // calculate the numbers that 
  context.fillText(text, coord[0], coord[1]);                   
}


Vue.component('draggable-dist', {
  props: {        
    chartHeight: {type: Number, default: 150},
    chartWidth: {type: Number, default: 500},
    guess1: {type: Number, default: 10},
    guess2: {type: Number, default: 10},

    // Optional max value to cap the distribution to.
    maxBound: {type: Number},
  },
  data(){
    return {
      betaA: 4, 
      betaB: 4, 
      yScale: 50,
      conf: [10, 20],
      dotLeft: 244,
      dotTop: 38,
      isDragging: false,

      mouseWithinDotPos: null,
    }
  },
  watch: {
    guess1(){
      this.init();
    },
    guess2(){
      this.init();
    }
  },
  mounted(){
    this.init();
  },
  computed: {
    guess(){
      return Math.round((this.guess1 + this.guess2)/2);
    },
    baseWidth(){
      return lerp(this.conf[1]-this.conf[0], 0, 100, 50, this.chartWidth);
    },
    mode(){
      return (this.betaA-1) / (this.betaA + this.betaB - 2); 
    },
    context(){
      return this.$refs['canvas'].getContext('2d');
    },
    redDotStyle(){
      if (this.isDragging){
        return {
          opacity: 0
        }
      }
      return this.ghostDotStyle;
    },
    ghostDotStyle(){
      return {
        left: this.dotLeft + 'px',
        top: this.dotTop + 'px'
      };
    }
  },
  methods: {
    init(){
      this.conf = [Math.min(this.guess1, this.guess2), Math.max(this.guess1, this.guess2)];
      this.plotFigure();
      this.plotAxis();
    },
    getPDF(val){
      if (val < this.conf[0] || val > this.conf[1]){
        return 0;
      }
      var true_x = lerp(val, this.conf[0], this.conf[1], 0, 1);
      return jStat.beta.pdf(true_x, this.betaA, this.betaB) / (this.conf[1]-this.conf[0]);
    },
    getRelativeMousePos: function(event, className){
      // https://stackoverflow.com/questions/5921413/difference-between-e-target-and-e-currenttarget
      // e.target is what triggers the event dispatcher to trigger and e.currentTarget is what you assigned your listener to.

      // Find the 'dist' element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== className){
        refElement = refElement.parentElement;
      }

      const result = {
        left: event.clientX - refElement.getBoundingClientRect().x,
        top: event.clientY - refElement.getBoundingClientRect().y
      };
      return result;
    },

    mousedown(event){
      this.isDragging = true;

      // Need this to create a more accurate ghost
      const mousePos = this.getRelativeMousePos(event, 'dot');
      this.mouseWithinDotPos = mousePos;
    },
    drag(event){
        const height = this.chartHeight;
        const width = this.chartWidth;
        const guess = this.guess;

        const mousePos = this.getRelativeMousePos(event, 'draggable-dist');
        const top = mousePos.top - this.mouseWithinDotPos.top;
        const left = mousePos.left - this.mouseWithinDotPos.left;
        if (top < 0 || left < 0){
          return;
        }
        this.dotTop = top;
        this.dotLeft = left;

        // Enforce a min beta because the distribution gets pretty spiky and unpredictable for lower values.
        const peakiness = (height - top) / height * 10;
        const skew = left/width;
        const beta_a = Math.max(1.2, peakiness * skew);
        const beta_b = Math.max(1.2, peakiness * (1-skew));

        
        // Convert distance from top to spread by enforcing 3 critical points (max, start, min).
        const origDistance = Math.abs(this.guess1-this.guess2)/2;
        const maxSpread = Math.min(origDistance*50, 150);
        const spreadScale = d3.scaleLinear()
          .domain([0, 28, height]).range([0, origDistance, maxSpread]);
        const spread = spreadScale(top);

        const mode = (beta_a - 1)/(beta_a + beta_b - 2);

        // Enforce positive lower bound for interval.
        const lowerConf = Math.max(0, this.guess - mode*spread);
        const upperConf = this.guess + (1-mode)*spread;     

        const conf = this.maxBound === undefined ? [lowerConf, upperConf] : [lowerConf, Math.min(upperConf, this.maxBound)];

        this.conf = conf;
        this.betaA = beta_a;
        this.betaB = beta_b;

        this.plotFigure();
        this.plotAxis();
     },
     dragend(){
        this.isDragging = false;

        // snap the draggable to the mode
        const y_scale = 50;
        const diameter = 10;

        const height = this.chartHeight;
        const width = this.chartWidth;

        const x = lerp(this.mode, 0, 1, (width - this.baseWidth)/2, (width + this.baseWidth)/2 );
        const y = jStat.beta.pdf(this.mode, this.betaA, this.betaB) * y_scale;
        const top = Math.max(0, height-y - diameter/2);

        this.dotLeft = x -diameter/2;
        this.dotTop = top;
     },

     plotFigure(){
        const context = this.context;
        const y_scale = 50;
        context.clearRect(0, 0, this.chartWidth, this.chartHeight);
 
        context.setTransform(this.baseWidth, 0, 0, -y_scale, (this.chartWidth-this.baseWidth)/2, this.chartHeight);
        
        const x_coords = _.range(0, 1, .01);
        var this_ = this;
        var y_coords = x_coords.map(function(x){
          return [x, jStat.beta.pdf(x, this_.betaA, this_.betaB)];
        });
        y_coords.push([1, y_coords[0][0]]);
        canvasPlotCoords(context, y_coords, 'rgba(27,64,99,.2)');      
     },

     plotAxis(){
        const context = this.context;
        context.setTransform(1, 0, 0, 1, 0, 0);

        const conf = this.conf;
        const guess = this.guess;

        const font = "18px Arial";
        const txtfont = '12px Arial';

        const width = this.chartWidth;
        const height = this.chartHeight;

        const yoff = -15;

        const low = Math.max((width - this.baseWidth)/2, 0);
        const high = Math.min( (width + this.baseWidth)/2 - 5, width-20 );
        canvasAddText(context, '[', [low, height], font);
        canvasAddText(context, Math.round(conf[0]), [low, height+yoff], txtfont);

        canvasAddText(context, ']', [high, height], font);
        canvasAddText(context, Math.round(conf[1]), [high, height+yoff], txtfont);

        if (conf[1] - conf[0] > 0  && conf[1] - guess > 2){
          const pos = lerp(this.mode, 0, 1, low, high);
          const val = Math.round(lerp(this.mode, 0, 1, conf[0], conf[1]));
          canvasAddText(context, '|', [pos, height], font);
          canvasAddText(context, val, [pos, height+yoff], txtfont);          
        }
      },
  },
  template: '#draggable-dist-template'
});


Vue.component('triple-bayes', {
  props: {

    hypotheses: {type: Array}, // ['Nice', 'Evil']
        
    chartHeight: {type: Number, default: 160},
    chartWidth: {type: Number, default: 120},

    // Missing keys from config are not rendered.
    // {prior: {dist: [1, 4]}, likelihood: {isActive: true, isDraggable: true, dist: [1, 10]}, posterior: {}}
    config: {type: Object},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '', dot: ''};
      }
    },
  },
  data: function(){
    return {
     conf: null,
     showFeedback: null,
    }
  },
  computed: {
    posteriorDist(){
      var distArr = _.zip(this.priorArr, this.likelihoodArr).map(x => _.reduce(x, _.multiply));
      if (_.max(distArr) > 9){ // Start attempting to simplify posterior when it gets too big.
        distArr = this.simplifiedArr(distArr);
      }
      return _.zipObject(this.hypotheses, distArr);
    },
    priorArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['prior'].dist || ones;
    },

    likelihoodArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['likelihood'].dist || ones;
    },
    allCorrect(){
      const keys = ['prior', 'likelihood', 'posterior'];
      const parts = keys.map(key => !this.conf[key] || !this.conf[key].correct || this.isEqual(this.conf[key].correct, this.conf[key].dist));
      return _.every(parts);
    }
  },
  created(){
    this.conf = _.cloneDeep(this.config);
  },
  methods: {
    isEqual(arr1, arr2){
      return _.isEqual(this.simplifiedArr(arr1), this.simplifiedArr(arr2));
    },
    // simplifiedArr([3, 6]) => [1, 2]
     simplifiedArr(arr){
      var maxFactor = _.min(arr);
      for (var i=maxFactor; i>1; i--){
        var isDivisible = _.every(arr.map(function(x){
          return Math.abs(x/i - Math.floor(x/i)) < .0001;
        }));
        if (isDivisible){
          break;
        }
      }
      var result = arr.map(x => Math.floor(x / i));
      return result;
    },
    title(key){
      if (this.conf[key].title !== undefined){
        return this.conf[key].title;
      }
      const defaultTitles = {
        'prior': 'Prior Belief',
        'likelihood': 'Likelihood Ratio',
        'posterior': 'Posterior Belief'
      };
      return defaultTitles[key];
    },
    subtitle(key){
      if (this.conf[key].subtitle !== undefined){
        return this.conf[key].subtitle;
      }
      const defaultTitles = {
        'prior': 'What you think before the evidence',
        'likelihood': 'Likelihood of the evidence under each hypothesis',
        'posterior': 'What you think after the evidence'
      };
      return defaultTitles[key];
    },
    hasKey(key){
      return this.conf[key];
    },
    isActive(key){
      return this.conf[key] && this.conf[key].isActive;
    },
    isDraggable(key){
      return this.conf[key] && this.conf[key].isDraggable;      
    },
    arrToDist(arr){
      return _.zipObject(this.hypotheses, arr);
    },
    isCompRight(key){
      return this.showFeedback && this.conf[key] && this.conf[key].correct && this.isEqual(this.conf[key].correct, this.conf[key].dist);
    },
    compStyle(key){
      return {opacity: this.conf[key] && this.conf[key].isActive ? 1 : 0.5};
    },
    likelihoodChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.likelihood, 'dist', distArr);
      this.refreshPosterior();
    },
    priorChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.prior, 'dist', distArr);
      this.refreshPosterior();
    },
    refreshPosterior(){
      if (this.$refs['posterior-samples-chart']){
        this.$refs['posterior-samples-chart'].countsFromProps()         
      }
    },
    submitClicked(){
      this.showFeedback=true;
      if(this.allCorrect){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }
        this.$emit('yay');
      }
    }
  },
  template: '#triple-bayes-template'
});

Vue.component('samples-chart', {
  props: {

    xdomain: {type: Array}, // ['H', 'T']

    // Specify either samples or dist
    samples: {type: Array}, // ['H', 'H', 'H', 'T']

    dist: {type: Object}, // {H: 3, T: 1}
        
    chartHeight: {type: Number, default: 100},
    chartWidth: {type: Number, default: 120},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 40, left: 10};
      }
    },

    showRatio: {type: Boolean, default: false}, 
    isDraggable: {type: Boolean, default: false}, 
    maxCounts: {type: Number, default: 15},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '', dot: ''};
      }
    },

  },
  computed: {
    xScale(){
      // Can only use for categorical domain.
      return d3.scaleBand()
          .domain(this.xdomain).paddingInner(.1).range([0, this.chartWidth]);
    },
    sumCounts(){
      //return _.sum(_.values(this.counts));
      return this.maxCounts;
    },
    yScale(){
      // const maxHeight = sumCounts == 1 ? this.xScale.bandwidth() : this.chartHeight;
      return d3.scaleLinear()
          .domain([0, this.sumCounts]).range([0, this.chartHeight]);
    },
    yScaleBandwidth(){
      return this.chartHeight / this.sumCounts;
    },
  },
  data: function(){
    return {
      isCreated: false,
      counts: null,
      draggedDot: null,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: async function() {
    this.countsFromProps();

    // Add the axis
    // Hack: for some reason axis needs to get added after a delay, or it doesn't show up.
    await wait(500);
    var xAxis = d3.axisBottom(this.xScale); //.ticks(8);
//    var yAxis = d3.axisLeft(this.yScale);

    const chart = d3.select(this.$el).select('.container');
//    chart.append('g').call(yAxis);
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);
  },
  watch: {
    samples(){
      this.countsFromProps();
    },
    dist(){
      this.countsFromProps();
    },
  },
  methods: {
    prob(x){
      const total = _.sum(_.values(this.counts));
      return this.$root.roundTo(this.counts[x]/total*100, 0);
    },
    dragstart(x){
      this.draggedDot = x;
    },
    dragend(){
      this.draggedDot = null; 
    },
    countsFromProps(){
      if (this.dist){
        this.counts = _.cloneDeep(this.dist);
      } else {
        const bins = _.groupBy(this.samples);
        this.counts = _.zipObject(this.xdomain, this.xdomain.map(function(x){
            return x in bins ? bins[x].length : 0;
          }));
      }
    },
    dotStyle(x){
      return {
        left: this.xScale(x)+ this.xScale.bandwidth()/2+ 4 + 'px', 
        bottom: this.yScale(this.counts[x]) + 24 + 'px',
        'background-color': this.colors.dot,
      };
    },
    drag(x, event){
      const distanceFromTop = this.getRelativeMouseY(event);
      if (distanceFromTop < 0){
        return;
      }
      const height = this.chartHeight - distanceFromTop;

      const numBars = Math.max(1, Math.floor(height / this.yScaleBandwidth));

      const isNewNumBars = this.counts[x] && this.counts[x] !== numBars;
      Vue.set(this.counts, x, numBars);

      if (isNewNumBars){
          this.$emit('dist-changed', {dist: this.counts});
      }
    },
    getRelativeMouseY: function(event){
      // https://stackoverflow.com/questions/5921413/difference-between-e-target-and-e-currenttarget
      // e.target is what triggers the event dispatcher to trigger and e.currentTarget is what you assigned your listener to.

      // Find the 'dist' element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'samples-chart'){
        refElement = refElement.parentElement;
      }
      return event.clientY - refElement.getBoundingClientRect().y;
    },

  },
  template: '#samples-chart-template'
});

Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  computed: {
    lastChild(){
      if (this.clickedChildren.length > 0){
        return this.clickedChildren[this.clickedChildren.length-1];
      }
    },
    showHint(){
      if (DEBUG){
        return true;
      }
      if (this.lastChild){
        return this.lastChild.isNope;
      }
      return false;
    }
  },
  data: function(){
    return {
      clickedChildren: [],
    }
  },
  template: '#buton-group-template'
});

Vue.component('centered', {
  template: '#centered-template'
});

Vue.component('bold', {
  template: '#bold-template'
});

Vue.component('moneybag-question', {
  props: {
    question: {type: Object}, 
    certainties: {type: Array, default: () => [.5, .6, .7, .8, .9]},
    numLoseIfWrongs: {type: Array, default: () => [1, 2, 3, 4, 9]},
    viz: {type: String, default: 'certainty'}
  },
  data(){
    return {
      userChoice: null,
      userCertainty: null,
      // stage: 0,
      // guess: null,
      userFeedback: null,
    };
  },
  methods: {
    finishQuestion(certainty){
      // $root.paramsFromCertainty(certainty);
      //debugger;
      this.$emit('done', {question: this.question, choice: this.userChoice, userCertainty: certainty});

      this.userFeedback = 'Your guess was ' + (this.question.answer === this.userChoice ? 'correct.' : 'incorrect.');
    }
  },
  template: '#moneybag-question-template',
});


Vue.component('dist-question', {
  props: {
    question: {type: Object}, 
  },
  data(){
    return {
      stage: 0,
      guess1: null,
      guess2: null,
    };
  },
  computed: {
    guessHeight(){
      return this.$refs['dist'].getPDF(this.question.answer);
    },
    result(){
      if (this.guessHeight > 0){
        return {gradUnits: this.guessHeight * 100};
      }
      return {dishDuty: 1};
    }
  },
  methods: {
    guessSubmitted(params){
      this.stage = Math.max(this.stage, 1);
      this.guess1 = Number(params.val);
    },
    secondGuessSubmitted(params){
      this.stage = 2;
      this.guess2 = Number(params.val);
    },
    beliefSubmitted(){
      this.stage = 3;
    },
    finishQuestion(){
      this.$emit('done', {result: this.result});
    }
  },
  template: '#dist-question-template',
});


Vue.component('intro-scene', {
  template: '#intro-scene-template'
});

Vue.component('thanks', {
  template: '#thanks-template'
});

Vue.component('beliefs-as-dists', {
  data: function(){
    return {
      questions: numericQuestions,
      questionInd: 0,
      showGame: false,

      results: [],
    };
  },
  computed:{
    dishDuty(){
      return _.sum(this.results.map(r => r.dishDuty || 0));
    },
    gradUnits(){
      return _.sum(this.results.map(r => r.gradUnits || 0));      
    }
  },
  methods:{
    nextQuestion(params){
      this.showGame = true;
      this.questionInd++;
      this.results.push(params.result);

      // No more questions.
      if(this.questionInd === this.questions.length){
        this.$refs['pset'].next();
      }
    },
  },
  template: '#beliefs-as-dists-template'
});

Vue.component('moneybag', {
  props: {
    color: {type: String, default: 'brown'},
    number: {type: Number, default: 1},
    width: {type: Number, default: 20},
    isHorizontal: {type: Boolean, default: true},
  },
  computed:{
    // e.g. 0.3, if numLoseIfWrong == 2.3.
    positiveFraction: function(){
      return this.number - Math.floor(this.number);
    },

    // {width: '10px', height:'30px', top:'-4px'}
    fractionalCoverStyle: function(){
      // compute the styling of a white square that is aligned right
      // which creates the illusion of the fractional moneybag.
      const fudge = 4;
      return {
        width: (1-this.positiveFraction) * this.width + 'px',
        height: this.width * 236/200 + fudge + 'px',
      };
    },
  },
  template: '#moneybag-template'
});

Vue.component('fair-bet', {
  props: {
    numWinIfRight: {type: Number, default: 1},
    numLoseIfWrong: {type: Number, default: 1},
    showCertainty: {type: Boolean, default: true},
  },
  computed:{
    percent: function(){
      var params = this.$root.paramsFromBet(this.numWinIfRight, this.numLosingMoneybags);
      return params.percent;
    },
  },
  template: '#fair-bet-template'
});


Vue.component('bayes-unit', {
  props: {
    rootMouseEvent: {type: MouseEvent}, 
  },
  data: function(){
    return {
      activePane: null,
      knowAboutArr: [], //['food', 'location'],
    };
  },
  watch:{
    activePane(){
      if (this.activePane === null){
       this.$root.isShowingSidePanel = false;       
      } else{
        this.$root.isShowingSidePanel = true;               
      }
    },
    rootMouseEvent(){
      // Hide the active pane when the user clicks outside the activePane.

      // If the user is not clicking within one of the panes, hide the pane.
      if (!isDescendant(this.$refs['panes'], this.rootMouseEvent.target)){
        this.activePane = null;
      }
    }
  },

  methods:{
    knowAbout(thing){
      return this.knowAboutArr.indexOf(thing) > -1;
    },
    showPane(paneName){
      return this.activePane === paneName;
    },
    togglePane(paneName){
      if(this.activePane === paneName){
        this.activePane = null;
        this.$root.play('close');
      } else {
        this.activePane = paneName; 
        this.$root.play('open');
      }
      const refName = paneName + '-toggle';
      this.$refs[refName].classList.remove('color-change');
    },
    toggleStyle(paneName){
      return {color: this.activePane === paneName ? '#000' : ''};
    },
    async highlight(refName){
      await wait(1000);
      this.$refs[refName].classList.add('color-change');
    }
  },
  template: '#bayes-unit-template'
});

Vue.component('overconfidence', {
  data: function(){
    return {

      certaintyBundle: {
        questions: certaintyQuestions,
        questionInd: 0,
        results: [],
      },

      moneybagBundle:{
        questions: moneybagQuestions,
        questionInd: 1,
        results: []
      },

      firstMoneybagPayout: null,
    };
  },
  computed: {
    certaintyAccuracy(){
      return this.averageAccuracy(this.certaintyBundle);
    },
    certaintySureness(){
      return this.averageSureness(this.certaintyBundle);
    },
    moneybagAccuracy(){
      return this.averageAccuracy(this.moneybagBundle);
    },
    moneybagSureness(){
      return this.averageSureness(this.moneybagBundle);
    },
    improvement(){
      return Math.abs(this.certaintyAccuracy - this.certaintySureness) - Math.abs(this.moneybagAccuracy - this.moneybagSureness);
    }
  },
  methods: {
    nextQuestion(params, bundle){
      bundle.questionInd++;
      bundle.results.push(params);

      // No more questions.
      if(bundle.questionInd === bundle.questions.length){
        this.$refs['pset'].next();
      }
    },
    // Returns: 74
    averageAccuracy(bundle){
      const mean =_.mean(bundle.results.map(x => x.choice === x.question.answer ? 1 : 0));
      return this.$root.roundTo(mean * 100);
    },
    // Returns: 74
    averageSureness(bundle){
      return this.$root.roundTo(_.mean(bundle.results.map(x => x.userCertainty)) * 100, 0);
    },
    logFirstMoneybagQuestion(params){
      this.moneybagBundle.results.push(params);

      if (params.choice === params.question.answer){
        this.firstMoneybagPayout = 1;
      } else {
        const bet = this.$root.paramsFromCertainty(params.userCertainty);
        this.firstMoneybagPayout = -1 * bet.numLoseIfWrong;
      }
      this.$refs['pset'].next();
    }
  },
  template: '#overconfidence-template'
});


// Child slot should call next() on the parent to advance.
Vue.component('pset', {
  computed: {
    elms(){
      return this.$slots.default.filter(x => x.tag).map(x => x.elm);
    }
  },
  data: function(){
    return {
      ind: 0, // active index
    };
  },

  mounted: function(){
    // Hides elements initially.
    if (!DEBUG){
      for (var i=1; i<this.elms.length; i++){
        this.elms[i].style.display = 'none';
      }      
    }

    this.$root.report(0);
  },
  methods: {
    next(){
      this.ind = this.ind + 1;
      if (this.ind >= this.elms.length){
        this.$emit('done');
        return;
      }

      // grey out previous indices
      for (var i=0; i<this.ind; i++){
        this.elms[i].style.opacity = 0.5;  
        this.elms[i].classList.add('disabled');  
      }

      // make current ind, fully visible
      this.elms[this.ind].style.display = 'inherit';

      this.$root.report(this.ind);
      this.$root.scrollWindow();
    }
  },
  template: '#pset-template'
});

// Put a buton inside a once-group to ensure it is only clicked once.
Vue.component('once-group', {
  data: function(){
    return {
      isClicked: false
    }
  },
  methods: {
    childClicked: function(childComponent) {
      if (this.isClicked){
        return;
      }
      this.isClicked = true;
    }
  },
  template: '#once-group-template',
});


const chapters = [
{
  component: 'intro-scene',
  image: 'monastery.png',
  description: 'The beginning'
},
{
  component: 'beliefs-as-dists',
  description: 'Beliefs as distributions',
  image: 'curve.png',
},
{
  component: 'bayes-unit',
  description: 'Bayes Rule',
  image: 'oracle.png',
},
{
  component: 'overconfidence',
  description: 'Overconfidence Bias',
  image: 'cookie.png',
},

{
  component: 'thanks',
  description: 'To be continued',
  image: 'bird-heart.png',
},

];

function formatPct(certainty){
  return roundTo(certainty*100, 0) + '%';
}

// round_to(2.777777, 0) -> 3
// round_to(2.777777, 2) -> 2.78
function roundTo(x, num_decimals){
  return parseFloat(x.toFixed(num_decimals));
}

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {
    chapters: chapters,
    chapterInd: DEBUG ? 2 : 0,
    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    //soundNameToCount: {},
    show: false,
    isPlaying: false,
    showTOC: false,

    isScrolling: false,


    windowWidth: 0,
    isShowingSidePanel: false,

    mouseEvent: null, 
  },
  computed: {
    currentChapter: function(){
      return this.chapters[this.chapterInd];
    },
    visibleScreen: function(){
      return this.currentChapter.component;
    },
    appStyle: function(){
      const isWideWindow = this.windowWidth > 500+600;
      return isWideWindow && this.isShowingSidePanel ? {left: '600px'} : {margin: '0 auto'};
    }
  },
  created() {
    //https://codepen.io/sethdavis512/pen/EvNKWw
    window.addEventListener('resize', this.handleResize)
    this.handleResize();
  },
  methods: {
    formatPct: formatPct,
    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,

    handleResize() {
      this.windowWidth = window.innerWidth;
    },
    nextChapter: async function(){
      // this.play('achievement');
      // await wait(1500);
      this.chapterInd = Math.min(this.chapters.length-1, this.chapterInd+1);
    },
    // Given 0.8 --> returns {}
    paramsFromCertainty: function(certainty){
      if (certainty == 1.0){
        return {
          numLoseIfWrong: 10000000, 
          numWinIfRight: 1,
          certainty: certainty,
          percent: '100%',
        };
      }
      return {
        numWinIfRight: 1, 
        numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
        certainty: certainty,
        percent: this.formatPct(certainty)
      };      
    },
    paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
      var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
      return this.paramsFromCertainty(certainty);
    },
    play: function(soundName){
      if (sounds[soundName] === undefined){
        return;
      }
      var sound = sounds[soundName].clip;
      sound.play().catch(function(error){
        console.log(error.toString());
      });    
    },
    mainClick(event){
      // When you click on the margins, event.target is the "app" node. 
      this.mouseEvent = event; 

      if (!isDescendant(this.$refs['toc'], event.target)){
        this.showTOC = false;
      }
    },
    nextChapter(){
      this.chapterInd++;
      window.scrollTo(0, 0);
    },
    async scrollWindow(){
      if (this.isScrolling){
        return;
      }

      var minNumScrolls = 3;
      this.isScrolling = true;
      // Scroll down a little bit and see if we should keep scrolling.
      // Stop scrolling if we've reached the bottom, 
      // Or if we have somehow traveled up (i.e. user has moved the mouse)
      while (true){
        const startY = window.scrollY;
        if (this.lastStartY >= startY && minNumScrolls <= 0){

          // Hack: Wait and try one more time to scroll before exiting. 
          // Seems like there might be a delay to add stuff to the DOM?
          await wait(100);
          window.scrollBy(0, 10);
          if (this.lastStartY >= window.scrollY){
            break;
          }
        }
        this.lastStartY = startY;
        window.scrollBy(0, 10);
        minNumScrolls--;
        await wait(30);
      }
      this.isScrolling = false;
    },
    report(ind){
      const chapterName = this.currentChapter.component;
      console.log('reporting ' + chapterName + ' ' + ind);
      gtag('event', 'cogbiases_v2', {
        'event_category': 'read',
        'event_label': chapterName,
        'value': ind
      });
    },


  } // end methods
});
</script>